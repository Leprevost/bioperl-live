# Bio::Tools::Alignment::Overview.pm
#
# Please direct questions and support issues to <bioperl-l@bioperl.org> 
#
# Cared for by Felipe da Veiga Leprevost
#
# Copyright Felipe da Veiga Leprevost
#
# You may distribute this module under the same terms as perl itself

# POD documentation - main docs before the code 

=head1 NAME

Bio::Tools::Alignment::Overview - an overview for large multiple sequence alignments.

=head1 SYNOPSIS

	use Bio::Tools::Alignment::Overview();

	my $view = Bio::Tools::Alignment::Overview->new();

	$view->input('path_to_my_align_file');
	$view->output('path_to_my_output_image_file'); # no extension is required.
	$view->color('color_name'); # 'red'

	$view->make_image();

=head1 DESCRIPTION

This module creates a simple and resumed representation of a biological sequence alignment. It 
helps by providing a bird's eye view of the alignment in the form of an image containing
only a simplified representation of the sequences as they are in the multiple alignment file.

=head1 FEEDBACK

=head2 Mailing Lists

User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.

  bioperl-l@bioperl.org                  - General discussion
  http://bioperl.org/wiki/Mailing_lists     - About the mailing
lists

=head2 Support 

Please direct usage questions or support issues to the mailing list:

I<bioperl-l@bioperl.org>

rather than to the module maintainer directly. Many experienced and 
reponsive experts will be able look at the problem and quickly 
address it. Please include a thorough description of the problem 
with code and data examples if at all possible.

=head2 Reporting Bugs

Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via the
web:

  https://redmine.open-bio.org/projects/bioperl/

=head1 AUTHOR - Felipe da Veiga Leprevost

Email leprevost-at-cpan.org

=head1 APPENDIX

The rest of the documentation details each of the object methods.
Internal methods are usually preceded with a _

=cut

package Bio::Tools::Alignment::Overview;

use strict;
use warnings;
use GD::Simple;

sub new {
	my ($class, @args) = @_;
	my $self = {};
	$self->{_fileInput}	= undef,
	$self->{_fileOutput}	= undef,
	$self->{_pencolor}	= 'blue',
	bless($self, $class);
	return $self;
}

=head2 INPUT.

	$object->input();

The module is compatible with alignments generated by other programs like ClustalW, MUSCLE and T-COFEE.

=cut

sub input {
	my $self = shift;
	if (@_) { $self->{_fileInput} = shift};
	return $self->{_fileInput};
}

=head2 OUTPUT.

	$object->output();

No extension is required for the output file, the module generates automatically a .png file. 

=cut

sub output {
	my $self = shift;
	if (@_) { $self->{_fileOutput} = shift};
	return $self->{_fileOutput};
}

=head2 COLOUR.

	$object->color();

The module depends on GD::Simple for making the images files so the available colors are listed in L<GD::Simple>.
The default color is blue.

=cut

sub color {
	my $self = shift;
	if (@_) { $self->{_pencolor} = shift};
	return $self->{_pencolor};
}

=head2 MAKE_IMAGE.

	$object->make_image();

This is the method responsible for generating the image file with png extension.

=cut

sub make_image{
	my $self = shift;   

	# variables;
	my $fileInPath	= $self->input or die "\n I think you forgot to pass me the input file. \n";
	my $fileOutPath	= $self->output or die "\n I think you forgot to pass me the output file. \n";
	my $_pencolor	= $self->color;	
	my $seqCounter	= 0;
	my $alignSize	= 0;
	my $proportion	= 0;
	my $height		= 0;
	my $penSize		= 6;
	my $background	= 'white';
	my $seqSpace	= 10;
	my $img			= '';
	my $x			= 10;
	my $y			= 10;
	my $position	= 0;
	my $char		= '';
	my %seqHash;
	my %sortedHash;
	
	open (my $fh, '<', "$fileInPath") or die "\n Can't load file, check the file name and its location \n";

	# iterates the file saving the sequences to a hash whit a 'id' number (seqCounter).
	while (my $line = <$fh>) {
	
		next if $line !~ m/^\S+/;
		chomp $line;

		if ($line =~ m/^\>(.+)/) {
			$seqCounter++;
			$seqHash{$seqCounter} = '';
		} else {
			$seqHash{$seqCounter} = $seqHash{$seqCounter}.$line;
			$alignSize = length($seqHash{$seqCounter});
		}
	}

	# gets the right proportion for images with 560 of weight.
	$proportion = $alignSize / 560;

	# the height is cauculated based on the number os sequences in the hash.
	$height = keys (%seqHash);

	# this is an adjustment of the tickness of the lines that will representate the sequences. With fewer sequences
	# the pensize gets bigger and vice versa.
	$penSize	= 6;
	$seqSpace	= 10; 
	
	if ($height > 20 && $height < 80) {
		$penSize	= 4;
		$seqSpace	= 8;	
	} elsif ($height >= 80) {
		$penSize	= 3;
		$seqSpace	= 5;
	}

	# last adjustment in height size.
	$height = ($height * $seqSpace) + 20;

	# now, lets draw!
	$img = GD::Simple->new(580, $height);
	$img->bgcolor(undef);
	$img->fgcolor('black');
	$img->rectangle(0,0,579, ($height -1));

	$x = 10;
	$y = 10;
	
	$img->bgcolor($background);
	$img->fgcolor($_pencolor);
	$img->penSize($penSize);
	$img->moveTo($x, $y);

	# first we create a new hash that will be sorted by sequence size.
	for my $key (keys %seqHash) {
		my $counter;
		$counter = $seqHash{$key} =~ s/(\w)/$1/g;
		$sortedHash{$key} = $counter;
	}

	# this is the part were the drawn is actually made.
	for my $key (sort { $sortedHash{$b} <=> $sortedHash{$a} } keys %sortedHash) {
		
		my @elements = split(//, $seqHash{$key});

		for my $char (@elements) {
			
			if ($char eq '-') {
				$position++;
				$img->moveTo( ($x + ($position / $proportion) ), ($y) );
			} else {
				$position++;
				$img->lineTo( ($x + ($position / $proportion) ), ($y) );
			}
		}
		
		$x = 10;
		$y += $seqSpace;
		$position = 0;
		$img->moveTo($x, $y);
	}
	
	open (my $fh2, '>', "$fileOutPath.png" ) or die "\n Can't create the image file, check if all depencies are installed correctly, specially GD::Simple! \n";
	print $fh2 $img->png;
}

1;
